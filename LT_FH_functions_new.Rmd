---
title: "LT_FH"
output: html_document
---


```{r}
library(bigsnpr)
library(dplyr)
library(ggplot2)
```

```{r}
get_cov = function(h2, n_sib = 0) {
  cov <- matrix(h2/2, 4 + n_sib, 4 + n_sib)
  diag(cov) <- 1
  cov[3,4] <- cov[4,3] <- 0
  cov[1:2, 1] <- cov[1, 1:2] <- h2
  cov
}
```

```{r}
calc_distribution = function(sigma){
  out = list()
  for (i in 1:nrow(sigma)){
    mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
    sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
    out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
    }
  return(out)
  }
```


```{r}
# Vores gibbssampler


Gibbs <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){

  
  k = nrow(covmat)

  const_list = calc_distribution(covmat)
  
  liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
  
  current_liabil = rep(s_val, k)
  
  start_run = 500
  s = 0
  p = 0
  
  while(TRUE) {
    p = p +1
  for (i in 2:start_run) {
    s = s + 1
    for (j in 1:k) {
      # Udregner parametre
      sigma = const_list[[j]]$sigma
      mu_mult_ = const_list[[j]]$mu_mult
      mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
    
      
      if (j == 1) {
        current_liabil[j] = rnorm(1, mu, sqrt(sigma))
      }
      else {
        crit <- qnorm(1-K)
        crit_bound = pnorm(crit, mu, sqrt(sigma))
        
        interval_2 = c(0, crit_bound)
        interval_1 = c(crit_bound, 1)
        
        phen = phenos[j-1]
        interval = phen * interval_1 + (1-phen)*interval_2
        U = runif(1,interval[1], interval[2])
        current_liabil[j] = qnorm(U, mu, sqrt(sigma))
      }
      
    
    if(s > start_run){
      liabil[i+start_run*(p-2),] = current_liabil
    }
    }
  }

  if(s>(start_run+min_run)){
      end_val = s-start_run
      if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
        if (all_est){
          return(liabil[1:end_val,])
        }
        return(colMeans(liabil[1:end_val,]))
        
      }
  }
      
  }
}
  
```







```{r}
covmat = get_cov(0.5)
Gibbs(covmat, c(0,0,1))
```

```{r}
Gibbs_notrunc <- function(covmat, N=3000, K = 0.05, s_val = 0){

  k = nrow(covmat)

  const_list = calc_distribution(covmat)

  liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
  mu_vec = matrix(s_val, nrow = N-1, ncol = k)
  current_liabil = rep(s_val, k)

  for (i in 1:(N)) {
    for (j in 1:k) {
      # Udregner parametre
      sigma = const_list[[j]]$sigma
      mu_mult = const_list[[j]]$mu_mult
      mu = mu_mult %*% current_liabil[-j] # Udelukker den liability vi er kommet til
      mu_vec[i,j] = mu
      current_liabil[j] = rnorm(1, mu, sqrt(sigma))
    }
    liabil[i,] = current_liabil
  }
  
  
  return(list('liabilities'=liabil, 'mu'=mu_vec))
}
```




```{r}
get_names <- function(values, n_sib=0, id= TRUE, parents=TRUE){
  
  len = length(values)
  prefix = c(rep("", len*id), rep("p",len*2*parents), rep("s",n_sib*len))
  
  n_peop = 1*id + 2*parents + n_sib
  index = c(rep(0,id), rep(c(1:2),parents), rep(c(3:(2+n_sib)),n_sib!=0))
  
  name = rep("", len*(n_peop))
  j = 1
  for (i in 1:n_peop){
    name[j:(j+len-1)] = paste0((paste(values,prefix[j:(j+len-1)], sep="_")), rep(index[i], len))
    j = j + len
  }
  return(name)
}


get_names(c("l_g","l_e"), id=TRUE, parents = FALSE, )
```



```{r}
 estimate_conf = function(unique_comb, h2=0.5, n_sib=0, K=0.5){
   k = ncol(unique_comb)
   covmat = get_cov(h2, n_sib)
   
   
   estimates = matrix(NA, nrow = nrow(unique_comb), ncol=4+n_sib)
    for (i in 1:nrow(unique_comb)){
      estimates[i,] = Gibbs(covmat, unique_comb[i,], K=K)
    } 
   
   uneven_seq = seq(1,k*2,2)
   even_seq = seq(2,k*2,2)

   out = matrix(0, nrow=nrow(unique_comb), ncol=k*2)
   
   for (i in 1:k){
     out[,uneven_seq[i]] = unique_comb[,i]
     out[,even_seq[i]] = estimates[,i]
   }
   col_names = get_names(c("phen", "est_l_g"), n_sib)
   colnames(out) = col_names
   return(out)
 }

```


```{r}
calc_phen = function(liabilities, n_sib=0, K=0){
  T_ = qnorm(1-K)
  N = nrow(liabilities)
  k = 3+n_sib
  full_liabil = matrix(0, nrow=N, ncol=k*2)
  for (i in 1:k){
    full_liabil[,(2*i-1)] = (liabilities[[i*2]] + liabilities[[i*2+1]])
    full_liabil[,(2*i)] = (liabilities[[i*2]] + liabilities[[i*2+1]]) >=T_
  }
  
  col_names=get_names(c("l","phen"), n_sib)
  colnames(full_liabil) = col_names

  return(full_liabil)
}

```

```{r}
estimate_liabilities = function(liabilities, K=0.05, n_sib=0, h2=0.5){
  k = 3+n_sib
  
  full_liabil = calc_phen(liabilities, n_sib, K)
  unique_comb = unique(full_liabil[,seq(2,k*2,2)])
  estimated_liabil = estimate_conf(unique_comb, h2, n_sib, K)
  
  key = get_names(c("phen"),n_sib) 
  temp = left_join(as_tibble(full_liabil),as_tibble(estimated_liabil),by=key)
  order = get_names(c("l", "l_g", "l_e", "phen", 'est_l_g'), n_sib)
  return(bind_cols(liabilities,temp) %>% relocate(order))
  
  
}


```



```{r}

#G = snp_attach("test2.rds")

G1 = snp_attach("test15.rds")

fam = G1$fam

k=estimate_liabilities(fam, n_sib=2)


```


```{r}
plot(k$est_l_g_0, k$l_g_0)
abline(a=0, b=1)
```
```{r}
# Calculate who is sick
y_func = function(l_e_0, l_g_0, K=0.05) {
  l_0 = l_g_0 + l_e_0
  T_ = qnorm(1-K)
  y = ifelse(l_0>=T_, 1, 0)
  return(y)
}
```

```{r}

y = y_func(G1$fam$l_g_0,G1$fam$l_e_0)
test = big_univLinReg(G1$genotypes, y, covar.train=matrix(k$est_l_g_0))
test$p.value <- predict(test, log10 = FALSE)
plot(test)

```

```{r}
bonferroni_correct = function(summary, alpha=0.05){

  p = alpha/1000000
  causal_estimate = (summary$p.value<=p)-0
  
  return(causal_estimate)
}
```

```{r}
result = bonferroni_correct(test)

```


```{r}

control_plot = function(h2, phenos, col="black"){
  covmat = get_cov(h2)
  estimates = Gibbs(covmat, phenos, all_est = TRUE, min_run = 8000)
  sd = sd(estimates[,1])
  mean = mean(estimates[,1])

  
  ggplot(data.frame(x = c(-2, 3)), aes(x = x)) +
    stat_function(fun = dnorm, args = list(mean = mean, sd = sd), mapping = aes(x),color=col) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = sqrt(h2)), mapping = aes(x)) +
    geom_vline(xintercept=mean, linetype="dashed",color=col) +
    geom_text(aes(x=mean+0.2, label=round(mean,2), y=0), colour=col)
  

  }

```

```{r}
par(mfrow=c(1,3))
control_plot(0.5, c(0,0,0), col="blue")
control_plot(0.5, c(0,0,1), col="purple")
control_plot(0.5, c(1,1,1), col="red")
```


