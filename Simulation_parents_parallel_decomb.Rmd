---
title: "Simulation_parents"
output: html_document
---

```{r}
library(bigsnpr)
library(dplyr)
library(future.apply)
library(tidyverse)
```



```{r}
get_names <- function(values, n_sib=0, id= TRUE, parents=TRUE){
  
  len = length(values)
  prefix = c(rep("", len*id), rep("p",len*2*parents), rep("s",n_sib*len))
  
  n_peop = 1*id + 2*parents + n_sib
  index = c(rep(0,id), rep(c(1:2),parents), rep(c(3:(2+n_sib)),n_sib!=0))
  
  name = rep("", len*(n_peop))
  j = 1
  for (i in 1:n_peop){
    name[j:(j+len-1)] = paste0((paste(values,prefix[j:(j+len-1)], sep="_")), rep(index[i], len))
    j = j + len
  }
  return(name)
}
```

```{r}
normalized_prod = function(Gx, probs, beta_cut){
  out = c(sweep(sweep(Gx[,], FUN = '-', STATS=2*probs, MARGIN = 2), FUN='/', STATS=sqrt(2*probs*(1-probs)), MARGIN = 2)  %*% beta_cut)
  return(out)
}


get_index = function(i, block_size){
  start = (i-1) * block_size + 1
  end = start + block_size - 1
  return(list('start'=start, 'end'=end))
}

get_member = function(i, beta, MAF, N=1e5, block_size=1000){
  
  index = get_index(i, block_size)
  probs = MAF[index$start:index$end]
  beta_cut = beta[index$start:index$end]
  
  Gx = matrix(rbinom(block_size*N, 2, probs), ncol=block_size, nrow=N, byrow = T)
  l_g_x = normalized_prod(Gx, probs, beta_cut)
  
  return(list('Gx'=Gx, 'l_g_x'=l_g_x))
}
  
assign_phen = function(G1, G2, N=1e5, block_size=1000){
  k = matrix(rnorm(block_size*N, 0, 0.0000001), ncol=block_size, nrow=N, byrow = T)
  G_input = round((G1 + G2)/2 - k)
  return(G_input)
}

```




```{r}
sim_basic = function(){
  
}





sim_fam = function(i, beta, MAF, n_sib = 0, N=1e5, block_size=1000){
    
  

    p1 = get_member(i, beta, MAF, N, block_size)
    p2 = get_member(i, beta, MAF, N, block_size)
    
    G1 = p1$Gx
    G2 = p2$Gx
    l_g_p1 = p1$l_g_x
    l_g_p2 = p2$l_g_x
    
    G_input = assign_phen(G1, G2, N, block_size)
    
    fam_tibble = tibble('l_g_partial_p1'=l_g_p1, 'l_g_partial_p2'=l_g_p2)
    
    
    # Siblings
    if (n_sib >0) {
      
    
    l_g_sibs = rep(list(rep(0,N)),n_sib)
    for (j in 1:n_sib){
      Gs = assign_phen(G1, G2, N, block_size)
      index = get_index(i, block_size)
      probs = MAF[index$start:index$end]
      beta_cut = beta[index$start:index$end]
      temp = normalized_prod(Gs, probs, beta_cut)
      l_g_sibs[[j]] = temp
    }
    
    s_tibble = do.call(cbind, l_g_sibs)
    col_names_g = get_names(c("l_g_partial"), id=FALSE, parents = FALSE, n_sib)
    colnames(s_tibble) = col_names_g
    fam_tibble = bind_cols(fam_tibble, s_tibble)
    }
    

    return(list('G_input'= G_input, 'fam_tibble'= fam_tibble))
    
    
}



```



```{r}
# Make G
G_func = function(filename, beta, MAF, fam = TRUE, n_sib = 0, N=1e5, M=1e5, block_size=1000){
  G = FBM.code256(nrow = N,
                    ncol = M,
                    code = c(0L, 1L, 2L, rep(NA_integer_, 256 - 3)),
                    backingfile = filename)
  
  
  l_g_p1 = rep(0, M)
  l_g_p2 = rep(0, M)
  
  iterations = M/block_size
  
  liabil = future_lapply(1:iterations, function(i){

    
    fam_sim = sim_fam(i, beta, MAF, n_sib, N, block_size)
    
    index = get_index(i, block_size)
    G[,index$start:index$end] = fam_sim$G_input
    fam_tibble = fam_sim$fam_tibble
    

    return(fam_tibble)
    },future.seed = TRUE) %>% 
   do.call(bind_cols, .) %>% collapse_data(., n_sib)
  return(list("G"=G, "liabil"=liabil))
  }
```


```{r}
collapse_data = function(data, n_sib){
  search = get_names("", id=FALSE, n_sib)
  expect_names = get_names("l_g", id=FALSE, n_sib)
  col_names = colnames(data)
  
  iterations = length(search)
  
  out = lapply(1:iterations, function(i) {
    new_col = rowSums(select(data, contains(search[i])))
    return(new_col)
    
  }) %>% do.call(bind_cols, .)
  
  colnames(out) = expect_names
  
  
  return(out)
  
}
```

```{r}
# Make beta
beta_func = function(C=1000, h_sq=0.5, M=1e5){
  beta = rep(0, M)
  beta[sample(M,C)] = rnorm(C, 0, sqrt(h_sq/C))
  return (beta)
}

```


```{r}
# Make liabilities
liabilities_func = function(G, MAF, beta, n_sib = 0, N=1e5, h_sq=0.5, block_size = 1000){
  l_g_0 = rep(0, N)
  iterations = N/block_size

  for (i in 1:iterations){
    current_start = (i-1) * block_size + 1
    current_end = current_start + block_size - 1
    l_g_0[current_start:current_end] = c(sweep(sweep(G[current_start:current_end,], FUN = '-', STATS=2*MAF, MARGIN = 2), FUN='/',
                                           STATS=sqrt(2*MAF*(1-MAF)), MARGIN = 2)  %*% beta)

  }
  
  l_e_0 = rnorm(N, 0, sqrt(1-h_sq))
  l_e_p1 = rnorm(N, 0, sqrt(1-h_sq))
  l_e_p2 = rnorm(N, 0, sqrt(1-h_sq))
  
  l_e_out = tibble(l_g_0, l_e_0, l_e_p1, l_e_p2)
  
  
  if (n_sib != 0){
    col_names = get_names(c("l_e"), id=FALSE, parents = FALSE, n_sib)
    l_e_sibs = as_tibble(matrix(rnorm(N * n_sib, 0, sqrt(1-h_sq)), ncol = n_sib))
    colnames(l_e_sibs) = col_names
    
  
  
    return(bind_cols(l_e_out,l_e_sibs))
  }
  else{
  return(l_e_out)
  }
}
```

```{r}
# Calculate who is sick
y_func = function(l_e_0, l_g_0, K=0.05) {
  l_0 = l_g_0 + l_e_0
  T_ = qnorm(1-K)
  y = ifelse(l_0>=T_, 1, 0)
  return(y)
}
```

```{r}
simulation = function (filename, h_sq=0.5, fam = TRUE, n_sib = 0, C=1000, K=0.05, N=1e5, M=1e5, block_size=1000) {
  # Make MAF
  MAF = runif(M, 0.01, 0.49)
  beta = beta_func(C, h_sq, M)
  G_l = G_func(filename, beta, MAF, fam = TRUE, n_sib, N, M, block_size)
  G = G_l$G
  liabil = G_l$liabil
  l_g_e = liabilities_func(G, MAF, beta, n_sib, N, h_sq, block_size)
  
  order = get_names(c("l_g","l_e"), n_sib) 
   
  out = bind_cols(liabil, l_g_e) %>% relocate(order)
  
  
   obj.bigsnp = list(genotypes = G, # genotypes, FBM object
                  map = tibble(snp = 1:ncol(G), MAF, beta), # map, i.e. SNP info
                  fam = bind_cols(tibble(FID = 1:nrow(G)), out)) # fam, i.e. info on individuals
   
   
   #saving the bigsnp object
   snp_save(obj.bigsnp)
  
}



```

```{r}
simulation("test39", C=100, N=1000, M=1000, n_sib = 2, block_size = 10)
```
```{r}
snp_attach("test10.rds")
```


